import{w as h}from"./chunk-B7GIP3BC-DUGFPHSp.js";import{_ as w,bi as T,bj as F,bk as M,bl as j,l as s,e as Y,bm as _,bn as H,bo as q,b9 as z,bp as O,bq as K,br as Q,bs as U,bt as V}from"./md-DDOO1ugQ.js";import{l as W}from"./chunk-CN5XARC6-D4wfwomh.js";import{G as k}from"./chunk-ULVYQCHC-C5lnfPPQ.js";import"./chunk-TZBO7MLI-BlwIb0Mm.js";import"./modules/vue-BY2y9pTo.js";import"./monaco/bundled-types-BomO3YJD.js";import"./modules/file-saver-igGfcqei.js";import"./lz-string-7V7f_eN4.js";import"./index-CjUswqsu.js";import"./modules/shiki-Ib1F0Tte.js";import"./slidev/default-BKAGt7Xj.js";import"./slidev/context-Cv-l1RMc.js";var d=new Map,E=new Map,P=new Map,Z=w(()=>{E.clear(),P.clear(),d.clear()},"clear"),S=w((n,t)=>{const e=E.get(t)||[];return s.trace("In isDescendant",t," ",n," = ",e.includes(n)),e.includes(n)},"isDescendant"),$=w((n,t)=>{const e=E.get(t)||[];return s.info("Descendants of ",t," is ",e),s.info("Edge is ",n),n.v===t||n.w===t?!1:e?e.includes(n.v)||S(n.v,t)||S(n.w,t)||e.includes(n.w):(s.debug("Tilt, ",t,",not in descendants"),!1)},"edgeInCluster"),B=w((n,t,e,o)=>{s.warn("Copying children of ",n,"root",o,"data",t.node(n),o);const l=t.children(n)||[];n!==o&&l.push(n),s.warn("Copying (nodes) clusterId",n,"nodes",l),l.forEach(c=>{if(t.children(c).length>0)B(c,t,e,o);else{const r=t.node(c);s.info("cp ",c," to ",o," with parent ",n),e.setNode(c,r),o!==t.parent(c)&&(s.warn("Setting parent",c,t.parent(c)),e.setParent(c,t.parent(c))),n!==o&&c!==n?(s.debug("Setting parent",c,n),e.setParent(c,n)):(s.info("In copy ",n,"root",o,"data",t.node(n),o),s.debug("Not Setting parent for node=",c,"cluster!==rootId",n!==o,"node!==clusterId",c!==n));const g=t.edges(c);s.debug("Copying Edges",g),g.forEach(a=>{s.info("Edge",a);const u=t.edge(a.v,a.w,a.name);s.info("Edge data",u,o);try{$(a,o)?(s.info("Copying as ",a.v,a.w,u,a.name),e.setEdge(a.v,a.w,u,a.name),s.info("newGraph edges ",e.edges(),e.edge(e.edges()[0]))):s.info("Skipping copy of edge ",a.v,"-->",a.w," rootId: ",o," clusterId:",n)}catch(X){s.error(X)}})}s.debug("Removing node",c),t.removeNode(c)})},"copy"),J=w((n,t)=>{const e=t.children(n);let o=[...e];for(const l of e)P.set(l,n),o=[...o,...J(l,t)];return o},"extractDescendants"),L=w((n,t,e)=>{const o=n.edges().filter(a=>a.v===t||a.w===t),l=n.edges().filter(a=>a.v===e||a.w===e),c=o.map(a=>({v:a.v===t?e:a.v,w:a.w===t?t:a.w})),r=l.map(a=>({v:a.v,w:a.w}));return c.filter(a=>r.some(u=>a.v===u.v&&a.w===u.w))},"findCommonEdges"),C=w((n,t,e)=>{const o=t.children(n);if(s.trace("Searching children of id ",n,o),o.length<1)return n;let l;for(const c of o){const r=C(c,t,e),g=L(t,e,r);if(r)if(g.length>0)l=r;else return r}return l},"findNonClusterChild"),p=w(n=>!d.has(n)||!d.get(n).externalConnections?n:d.has(n)?d.get(n).id:n,"getAnchorId"),I=w((n,t)=>{if(!n||t>10){s.debug("Opting out, no graph ");return}else s.debug("Opting in, graph ");n.nodes().forEach(function(e){n.children(e).length>0&&(s.warn("Cluster identified",e," Replacement id in edges: ",C(e,n,e)),E.set(e,J(e,n)),d.set(e,{id:C(e,n,e),clusterData:n.node(e)}))}),n.nodes().forEach(function(e){const o=n.children(e),l=n.edges();o.length>0?(s.debug("Cluster identified",e,E),l.forEach(c=>{const r=S(c.v,e),g=S(c.w,e);r^g&&(s.warn("Edge: ",c," leaves cluster ",e),s.warn("Descendants of XXX ",e,": ",E.get(e)),d.get(e).externalConnections=!0)})):s.debug("Not a cluster ",e,E)});for(let e of d.keys()){const o=d.get(e).id,l=n.parent(o);l!==e&&d.has(l)&&!d.get(l).externalConnections&&(d.get(e).id=l)}n.edges().forEach(function(e){const o=n.edge(e);s.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),s.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(n.edge(e)));let l=e.v,c=e.w;if(s.warn("Fix XXX",d,"ids:",e.v,e.w,"Translating: ",d.get(e.v)," --- ",d.get(e.w)),d.get(e.v)&&d.get(e.w)&&d.get(e.v)===d.get(e.w)){s.warn("Fixing and trying link to self - removing XXX",e.v,e.w,e.name),s.warn("Fixing and trying - removing XXX",e.v,e.w,e.name),l=p(e.v),c=p(e.w),n.removeEdge(e.v,e.w,e.name);const r=e.w+"---"+e.v+"---1",g=e.w+"---"+e.v+"---2";n.setNode(r,{domId:r,id:r,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setNode(g,{domId:g,id:g,labelStyle:"",padding:0,shape:"labelRect",style:"",width:10,height:10});const a=structuredClone(o),u=structuredClone(o),X=structuredClone(o);a.label="",a.arrowTypeEnd="none",a.id=e.name+"-cyclic-special-1",u.arrowTypeEnd="none",u.id=e.name+"-cyclic-special-mid",X.label="",a.fromCluster=e.v,X.toCluster=e.v,X.id=e.name+"-cyclic-special-2",n.setEdge(l,r,a,e.name+"-cyclic-special-0"),n.setEdge(r,g,u,e.name+"-cyclic-special-1"),n.setEdge(g,c,X,e.name+"-cyclic-special-2")}else if(d.get(e.v)||d.get(e.w)){if(s.warn("Fixing and trying - removing XXX",e.v,e.w,e.name),l=p(e.v),c=p(e.w),n.removeEdge(e.v,e.w,e.name),l!==e.v){const r=n.parent(l);d.get(r).externalConnections=!0,o.fromCluster=e.v}if(c!==e.w){const r=n.parent(c);d.get(r).externalConnections=!0,o.toCluster=e.w}s.warn("Fix Replacing with XXX",l,c,e.name),n.setEdge(l,c,o,e.name)}}),s.warn("Adjusted Graph",h(n)),A(n,0),s.trace(d)},"adjustClustersAndEdges"),A=w((n,t)=>{var l,c;if(s.warn("extractor - ",t,h(n),n.children("D")),t>10){s.error("Bailing out");return}let e=n.nodes(),o=!1;for(const r of e){const g=n.children(r);o=o||g.length>0}if(!o){s.debug("Done, no node has children",n.nodes());return}s.debug("Nodes = ",e,t);for(const r of e)if(s.debug("Extracting node",r,d,d.has(r)&&!d.get(r).externalConnections,!n.parent(r),n.node(r),n.children("D")," Depth ",t),!d.has(r))s.debug("Not a cluster",r,t);else if(!d.get(r).externalConnections&&n.children(r)&&n.children(r).length>0){s.warn("Cluster without external connections, without a parent and with children",r,t);let a=n.graph().rankdir==="TB"?"LR":"TB";(c=(l=d.get(r))==null?void 0:l.clusterData)!=null&&c.dir&&(a=d.get(r).clusterData.dir,s.warn("Fixing dir",d.get(r).clusterData.dir,a));const u=new k({multigraph:!0,compound:!0}).setGraph({rankdir:a,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});s.warn("Old graph before copy",h(n)),B(r,n,u,r),n.setNode(r,{clusterNode:!0,id:r,clusterData:d.get(r).clusterData,label:d.get(r).label,graph:u}),s.warn("New graph after copy node: (",r,")",h(u)),s.debug("Old graph after copy",h(n))}else s.warn("Cluster ** ",r," **not meeting the criteria !externalConnections:",!d.get(r).externalConnections," no parent: ",!n.parent(r)," children ",n.children(r)&&n.children(r).length>0,n.children("D"),t),s.debug(d);e=n.nodes(),s.warn("New list of nodes",e);for(const r of e){const g=n.node(r);s.warn(" Now next level",r,g),g.clusterNode&&A(g.graph,t+1)}},"extractor"),R=w((n,t)=>{if(t.length===0)return[];let e=Object.assign([],t);return t.forEach(o=>{const l=n.children(o),c=R(n,l);e=[...e,...c]}),e},"sorter"),ee=w(n=>R(n,n.children()),"sortNodesByHierarchy"),G=w(async(n,t,e,o,l,c)=>{s.info("Graph in recursive render: XXX",h(t),l);const r=t.graph().rankdir;s.trace("Dir in recursive render - dir:",r);const g=n.insert("g").attr("class","root");t.nodes()?s.info("Recursive render XXX",t.nodes()):s.info("No nodes found for",t),t.edges().length>0&&s.info("Recursive edges",t.edge(t.edges()[0]));const a=g.insert("g").attr("class","clusters"),u=g.insert("g").attr("class","edgePaths"),X=g.insert("g").attr("class","edgeLabels"),m=g.insert("g").attr("class","nodes");await Promise.all(t.nodes().map(async function(f){const i=t.node(f);if(l!==void 0){const v=JSON.parse(JSON.stringify(l.clusterData));s.trace(`Setting data for parent cluster XXX
 Node.id = `,f,`
 data=`,v.height,`
Parent cluster`,l.height),t.setNode(l.id,v),t.parent(f)||(s.trace("Setting parent",f,l.id),t.setParent(f,l.id,v))}if(s.info("(Insert) Node XXX"+f+": "+JSON.stringify(t.node(f))),i!=null&&i.clusterNode){s.info("Cluster identified XBX",f,i.width,t.node(f));const{ranksep:v,nodesep:b}=t.graph();i.graph.setGraph({...i.graph.graph(),ranksep:v+25,nodesep:b});const y=await G(m,i.graph,e,o,t.node(f),c),N=y.elem;_(i,N),i.diff=y.diff||0,s.info("New compound node after recursive render XAX",f,"width",i.width,"height",i.height),H(N,i)}else t.children(f).length>0?(s.info("Cluster - the non recursive path XBX",f,i.id,i,i.width,"Graph:",t),s.info(C(i.id,t)),d.set(i.id,{id:C(i.id,t),node:i})):(s.trace("Node - the non recursive path XAX",f,i.id,i),await q(m,t.node(f),r))})),await w(async()=>{const f=t.edges().map(async function(i){const v=t.edge(i.v,i.w,i.name);s.info("Edge "+i.v+" -> "+i.w+": "+JSON.stringify(i)),s.info("Edge "+i.v+" -> "+i.w+": ",i," ",JSON.stringify(t.edge(i))),s.info("Fix",d,"ids:",i.v,i.w,"Translating: ",d.get(i.v),d.get(i.w)),await V(X,v)});await Promise.all(f)},"processEdges")(),s.info("Graph before layout:",JSON.stringify(h(t))),s.info("############################################# XXX"),s.info("###                Layout                 ### XXX"),s.info("############################################# XXX"),W(t),s.info("Graph after layout:",JSON.stringify(h(t)));let D=0,{subGraphTitleTotalMargin:x}=z(c);return await Promise.all(ee(t).map(async function(f){var v;const i=t.node(f);if(s.info("Position XBX => "+f+": ("+i.x,","+i.y,") width: ",i.width," height: ",i.height),i!=null&&i.clusterNode)i.y+=x,s.info("A tainted cluster node XBX1",f,i.id,i.width,i.height,i.x,i.y,t.parent(f)),d.get(i.id).node=i,O(i);else if(t.children(f).length>0){s.info("A pure cluster node XBX1",f,i.id,i.x,i.y,i.width,i.height,t.parent(f)),i.height+=x,t.node(i.parentId);const b=(i==null?void 0:i.padding)/2||0,y=((v=i==null?void 0:i.labelBBox)==null?void 0:v.height)||0,N=y-b||0;s.debug("OffsetY",N,"labelHeight",y,"halfPadding",b),await K(a,i),d.get(i.id).node=i}else{const b=t.node(i.parentId);i.y+=x/2,s.info("A regular node XBX1 - using the padding",i.id,"parent",i.parentId,i.width,i.height,i.x,i.y,"offsetY",i.offsetY,"parent",b,b==null?void 0:b.offsetY,i),O(i)}})),t.edges().forEach(function(f){const i=t.edge(f);s.info("Edge "+f.v+" -> "+f.w+": "+JSON.stringify(i),i),i.points.forEach(N=>N.y+=x/2);const v=t.node(f.v);var b=t.node(f.w);const y=Q(u,i,d,e,v,b,o);U(i,y)}),t.nodes().forEach(function(f){const i=t.node(f);s.info(f,i.type,i.diff),i.isGroup&&(D=i.diff)}),s.warn("Returning from recursive render XAX",g,D),{elem:g,diff:D}},"recursiveRender"),me=w(async(n,t)=>{var c,r,g,a,u,X;const e=new k({multigraph:!0,compound:!0}).setGraph({rankdir:n.direction,nodesep:((c=n.config)==null?void 0:c.nodeSpacing)||((g=(r=n.config)==null?void 0:r.flowchart)==null?void 0:g.nodeSpacing)||n.nodeSpacing,ranksep:((a=n.config)==null?void 0:a.rankSpacing)||((X=(u=n.config)==null?void 0:u.flowchart)==null?void 0:X.rankSpacing)||n.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),o=t.select("g");T(o,n.markers,n.type,n.diagramId),F(),M(),j(),Z(),n.nodes.forEach(m=>{e.setNode(m.id,{...m}),m.parentId&&e.setParent(m.id,m.parentId)}),s.debug("Edges:",n.edges),n.edges.forEach(m=>{e.setEdge(m.start,m.end,{...m},m.id)}),s.warn("Graph at first:",JSON.stringify(h(e))),I(e),s.warn("Graph after:",JSON.stringify(h(e)));const l=Y();await G(o,e,n.type,n.diagramId,void 0,l)},"render");export{me as render};
